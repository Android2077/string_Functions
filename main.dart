import 'dart:io';
import 'dart:typed_data';    //Нужен для "Uint8List"
import 'dart:convert';       //для utf8.encode()

import 'Get_Split_PointerRanges__class.dart'                  as Get_Split_PointerRanges__class;
import 'Get_Split_AllPointerRanges__class.dart'               as Get_Split_AllPointerRanges__class;
import 'Get_SubstrBetweenSubstr_PointerRanges__class.dart'    as Get_SubstrBetweenSubstr_PointerRanges__class;
import 'Get_SubstrBetweenSubstr_AllPointerRanges__class.dart' as Get_SubstrBetweenSubstr_AllPointerRanges__class;
import 'Get__Replace__class.dart'                             as Get__Replace__class;



void main()
{

  //Под String - в данном случае имееется ввиду сырой буффер байт Uint8List - аналогчиный по сути std::vector<unsigned char> или std::vector<uint8_t> из C++.


  //---------------------------------------------------------------------------------------------ОГЛАВЛЕНИЕ:НАЧАЛО-----------------------------------------------------------------------------------------

  //1 - Get_SubstrBetweenSubstr_PointerRanges__class:             Это класс, который ищет подстроки между указанной левой и правой подстрокой и возвращает указатели на найденные подстроки.
  //2 - Get_SubstrBetweenSubstr_AllPointerRanges__class:          Эта функия точно так же, как и "Get_SubstrBetweenSubstr_PointerRanges__class" возвращает указатели на подстроки между подстроками, НО ДОПОЛНИТЕЛЬНО возвращает еще указатели и их размеры на сами Ограничевающме подстроки, и то, что между ними.
  //3 - Get_Split_AllPointerRanges__class:                        Эта функция Split - разделения строки по заданной подстроке на ВСЕ диапазоны, вообщем функция возвращает указатели и размеры по ВСЕМ разделенным диапазонам
  //4 - Get_Split_PointerRanges__class:                           Эта функция Split - разделения строки по заданной подстроке на диапазоны, вообщем функция возвращает указатели и размеры на диапазоны разделения.
  //5 - Get__Replace__class                                       Это класс замены подстроки на указанную подстроку.

  //---------------------------------------------------------------------------------------------ОГЛАВЛЕНИЕ:КОНЕЦ-----------------------------------------------------------------------------------------









  //--------------------------------------------------------------------------------------1-Get_SubstrBetweenSubstr_PointerRanges__class::Начало---------------------------------------------------------------------------


  //Доступные методы:
  //-get_vector_pointer__EndPointer            - делает Split с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки. Для этого внутри испотзуется "memcmp" для поиска подстроки.
  //-get_vector_string__EndPointer             - делает Split с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки. Для этого внутри испотзуется "memcmp" для поиска подстроки.
  //-get_vector_pointer__with_pass             - то же самое, что и "get_vector_pointer" - только с указанием кол-во пропуска "правой искомой подстроки". Подробнее читать в писании самой функции.
  //-get_vector_string__with_pass              - то же самое, что и "get_vector_string"  - только с указанием кол-во пропуска "правой искомой подстроки". Подробнее читать в писании самой функции.


  //----------------------------------------------------------------------------------------А-get_vector_pointer__EndPointer:Начало---------------------------------------------------------------------------------------------

  //Это класс, который ищет подстроки между указанной левой и правой подстрокой и возвращает указатели на найденные подстроки.
	//ВНИМАНИЕ: ЕСЛИ между искомымы подстроками - будет точно такая же комбинации Левой и Правой подстроки, ТО: Для примера: 1[SMS[V]1][SMS2]{GEO/}[SMS34] - если мы ищем подстроку между "[" и "]" - и внутри этих есть такая же кобианция этих подстрок "[V]", то функция будет расматривать это как отдельные Комбинации, то есть как "[ SMS[V ]", а не как "[ SMS[V]1 ]".

/*
  Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class My_GET_pointer_substring = new Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class();


	Uint8List my_string = Uint8List.fromList(utf8.encode("1[SMS1][SMS2]{GEO/}[SMS34]5"));  //"1[SMS1][SMS2]{GEO/}[SMS34]";


	//---------------------------------------------------------------------------------------------------
	Get_SubstrBetweenSubstr_PointerRanges__class.request_struct req_ = new Get_SubstrBetweenSubstr_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("[")), "[".length, Uint8List.fromList(utf8.encode("]")), "]".length );       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
	//req_.left_p = Uint8List.fromList(utf8.encode("["));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.left_size = "[".length;                                      //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

	//req_.right_p = Uint8List.fromList(utf8.encode("]"));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.right_size = "[".length;                                        //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!



	List<Get_SubstrBetweenSubstr_PointerRanges__class.result_struct> vec_result = [];       //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.
	//Get_SubstrBetweenSubstr_PointerRanges__class.result_struct                            //Структура результата содержит указатель left_p на первый левый символ найднной подстроки и второе поле size - размер найденной подтроки начиная с первого левого left_p байта.

	final int beg = 1;                     //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
	final int end = my_string.length-1;    //Указатель на конец диапазона в строке, до котрого включительно необходимо искать.
	//---------------------------------------------------------------------------------------------------


	//---------------------------------------------------------------------------------------------------
	final int result = My_GET_pointer_substring.get_vector_pointer__EndPointer(my_string, beg, end, req_, vec_result);      //Функция возвращает кол-во найденных последовталеьностей. 0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.

	if (result == 0)
	{
		print("Substr not found");
		return;
	}

	print('result:${result}');

	for (int i = 0; i < vec_result.length; i++)
	{

		if (vec_result[i].size == 0)
		{
			//Значит комбинация Левой и Правой подстроки была Найдена, но между ними ничего не было.

			print('${vec_result[i].left_p}:${vec_result[i].size }');    //Выводим результат.     //Выводим результат. vec_result[i].left_p - в том случае указыват на начало Левой искомой подстроки.
		}
		else
		{
       print('${vec_result[i].left_p}:${vec_result[i].size }');    //Выводим результат.
		}
	}
	//---------------------------------------------------------------------------------------------------

*/
  //----------------------------------------------------------------------------------------А-get_vector_pointer__EndPointer:Начало---------------------------------------------------------------------------------------------





  //----------------------------------------------------------------------------------------B-get_vector_string__EndPointer:Начало---------------------------------------------------------------------------------------------

	//Это класс, который ищет подстроки между указанной левой и правой подстрокой и возвращает std::string на найденные подстроки.
	//ВНИМАНИЕ: ЕСЛИ между искомымы подстроками - будет точно такая же комбинации Левой и Правой подстроки, ТО: Для примера: 1[SMS[V]1][SMS2]{GEO/}[SMS34] - если мы ищем подстроку между "[" и "]" - и внутри этих есть такая же кобианция этих подстрок "[V]", то функция будет расматривать это как отдельные Комбинации, то есть как "[ SMS[V ]", а не как "[ SMS[V]1 ]".


/*
	Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class My_GET_pointer_substring = new Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class();


	Uint8List my_string = Uint8List.fromList(utf8.encode("1[SMS1][SMS2]{GEO/}[SMS34]5"));  //"1[SMS1][SMS2]{GEO/}[SMS34]";


	//---------------------------------------------------------------------------------------------------
	Get_SubstrBetweenSubstr_PointerRanges__class.request_struct req_ = new Get_SubstrBetweenSubstr_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("[")), "[".length, Uint8List.fromList(utf8.encode("]")), "]".length );       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
	//req_.left_p = Uint8List.fromList(utf8.encode("["));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.left_size = "[".length;                                      //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

	//req_.right_p = Uint8List.fromList(utf8.encode("]"));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.right_size = "[".length;                                        //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

	List<Uint8List?>vec_result=[];                                             //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.


	final int beg = 1;                     //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
	final int end = my_string.length-1;    //Указатель на конец диапазона в строке, до котрого включительно необходимо искать.
	//---------------------------------------------------------------------------------------------------


	//---------------------------------------------------------------------------------------------------
	final int result = My_GET_pointer_substring.get_vector_string__EndPointer(my_string, beg, end, req_, vec_result);      //Функция возвращает кол-во найденных последовталеьностей. 0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.

	if (result == 0)
	{
		print("Substr not found");
		return;
	}



	print('result:${result}');

	for (int i = 0; i < vec_result.length; i++)
	{

		if (vec_result[i].size() == 0)
		{
			print(vec_result[i]);     //Выводим результат. Значит комбинация Левой и Правой подстроки была Найдена, но между ними ничего не было.
		}
		else
		{
		print(vec_result[i]);                     //Выводим результат.
		print(utf8.decode(vec_result[i]!));       //Просто для удобства наглядности сонвертируем его в String.[Если в vec_result[i] не валдиная UTF-8 кодировка, то рантайм выдаст ошибку.]
		}
	}

	//---------------------------------------------------------------------------------------------------
*/

  //----------------------------------------------------------------------------------------B-get_vector_string__EndPointer:Начало---------------------------------------------------------------------------------------------




  //----------------------------------------------------------------------------------------E-get_vector_pointer__with_pass:Начало---------------------------------------------------------------------------------------------

	//Это класс, который ищет подстроки между указанной левой и правой подстрокой и возвращает указатели на найденные подстроки - С УКАЗАНЕИМ КОЛ-ВА ПРОПУСКОВ ПРАВОЙ ИСКОМОЙ ПОДСТРОКИ.
	//ПОЯСНЕНИЕ: предположим есть строка - "1[S[]MS1][SMS2]{GEO/}[SMS34]5", в которой нужно найти подстроку между левой и правой подстроками "[" и "]" - однако как видно, между этими подстроками может встретится подстрока типа "S[]" - если применить обыную функцию "get_vector_pointer" то функция естесвенно найдет первую встречную правую подстроку "]" и результат будет "S]"  - и вот, чтобы результат был "S[]MS1" то нужно использовать эту данную функцию с указанием кол-ва пропусков Комбанций искомой Левой и Правой подстрок. Если указать "1" то комбинация Левой и Правой искомых подстрок "[" "]" будет пропущена один раз до следующей "]", если указать значение "2" - то будет пропущено два раза итд. Думаю понятно.
  //ВНИМАНИЕ: ВНУТРИ пропускаемых Левых и Правых подстрок - НЕ ДОЛЖЕР встречатся таких же комбинаций Левой и Правой подстрок - иначе функция выдаст некорректный результат..



	/*
  Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class My_GET_pointer_substring = new Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class();


  Uint8List my_string = Uint8List.fromList(utf8.encode("1[S[1]MS1][SMS2]{GEO/}[SMS34]5"));  //"1[SMS1][SMS2]{GEO/}[SMS34]"; "1[SMS1][SMS2]{GEO/}[SMS34]5"; "1[S[1][2]MS1][SMS2]{GEO/}[SMS34]5"


  //---------------------------------------------------------------------------------------------------
  Get_SubstrBetweenSubstr_PointerRanges__class.request_struct req_ = new Get_SubstrBetweenSubstr_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("[")), "[".length, Uint8List.fromList(utf8.encode("]")), "]".length );       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
  //req_.left_p = Uint8List.fromList(utf8.encode("["));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
  //req_.left_size = "[".length;                                      //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

  //req_.right_p = Uint8List.fromList(utf8.encode("]"));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
  //req_.right_size = "[".length;                                        //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!



  List<Get_SubstrBetweenSubstr_PointerRanges__class.result_struct> vec_result = [];       //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.
  //Get_SubstrBetweenSubstr_PointerRanges__class.result_struct                            //Структура результата содержит указатель left_p на первый левый символ найднной подстроки и второе поле size - размер найденной подтроки начиная с первого левого left_p байта.

  final int beg = 0;                     //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
  final int end = my_string.length-1;    //Указатель на конец диапазона в строке, до котрого включительно необходимо искать.

	int pass_number = 1;                                  //Кол-во пропусков "правой искомой подстроки".
	// ---------------------------------------------------------------------------------------------------



	//---------------------------------------------------------------------------------------------------
  final int result = My_GET_pointer_substring.get_vector_pointer__with_pass(my_string, beg, end, req_, pass_number, vec_result);      //Функция возвращает кол-во найденных последовталеьностей. 0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.


	if (result == 0)
	{
		print("Substr not found");
    return;
	}

	print('result:${result}');

	for (int i = 0; i < vec_result.length; i++)
	{
		if (vec_result[i].size == 0)
		{
			//Значит комбинация Левой и Правой подстроки была Найдена, но между ними ничего не было.

			print('${vec_result[i].left_p}:${vec_result[i].size}'); //Выводим результат.   //Выводим результат. vec_result[i].left_p - в том случае указыват на начало Левой искомой подстроки.
		}
    else
    {
			print('${vec_result[i].left_p}:${vec_result[i].size}'); //Выводим результат.
		}

	}
	//---------------------------------------------------------------------------------------------------
  */


  //----------------------------------------------------------------------------------------E-get_vector_pointer__with_pass:Начало---------------------------------------------------------------------------------------------







  //----------------------------------------------------------------------------------------F-get_vector_string__with_pass:Начало---------------------------------------------------------------------------------------------

	//Это класс, который ищет подстроки между указанной левой и правой подстрокой и возвращает std::string на найденные подстроки  - С УКАЗАНЕИМ КОЛ-ВА ПРОПУСКОВ ПРАВОЙ ИСКОМОЙ ПОДСТРОКИ.
	//ПОЯСНЕНИЕ: предположим есть строка - "1[S[]MS1][SMS2]{GEO/}[SMS34]5", в которой нужно найти подстроку между левой и правой подстроками "[" и "]" - однако как видно, между этими подстроками может встретится подстрока типа "S[]" - если применить обыную функцию "get_vector_pointer" то функция естесвенно найдет первую встречную правую подстроку "]" и результат будет "S]"  - и вот, чтобы результат был "S[]MS1" то нужно использовать эту данную функцию с указанием кол-ва пропусков Комбанций искомой Левой и Правой подстрок. Если указать "1" то комбинация Левой и Правой искомых подстрок "[" "]" будет пропущена один раз до следующей "]", если указать значение "2" - то будет пропущено два раза итд. Думаю понятно.
  //ВНИМАНИЕ: ВНУТРИ пропускаемых Левых и Правых подстрок - НЕ ДОЛЖЕР встречатся таких же комбинаций Левой и Правой подстрок - иначе функция выдаст некорректный результат..

/*
	Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class My_GET_pointer_substring = new Get_SubstrBetweenSubstr_PointerRanges__class.Get_SubstrBetweenSubstr_PointerRanges__class();


	Uint8List my_string = Uint8List.fromList(utf8.encode("1[S[1]MS1][SMS2]{GEO/}[SMS34]5"));  //"1[SMS1][SMS2]{GEO/}[SMS34]"; "1[SMS1][SMS2]{GEO/}[SMS34]5"; "1[S[1][2]MS1][SMS2]{GEO/}[SMS34]5"


	//---------------------------------------------------------------------------------------------------
	Get_SubstrBetweenSubstr_PointerRanges__class.request_struct req_ = new Get_SubstrBetweenSubstr_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("[")), "[".length, Uint8List.fromList(utf8.encode("]")), "]".length );       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
	//req_.left_p = Uint8List.fromList(utf8.encode("["));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.left_size = "[".length;                                      //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

	//req_.right_p = Uint8List.fromList(utf8.encode("]"));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.right_size = "[".length;                                        //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!


	 List<Uint8List?> vec_result = [];                                                 //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.

   final int beg = 0;                     //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
   final int end = my_string.length-1;    //Указатель на конец диапазона в строке, до котрого включительно необходимо искать.

	 int pass_number = 1;                                  //Кол-во пропусков "правой искомой подстроки".
	//---------------------------------------------------------------------------------------------------


	//---------------------------------------------------------------------------------------------------
	final int result = My_GET_pointer_substring.get_vector_string__with_pass(my_string, beg, end, req_, pass_number, vec_result);      //Функция возвращает кол-во найденных последовталеьностей. 0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.


	if (result == 0)
	{
		print("Substr not found");
		return;
	}

	print('result:${result}');


	for (int i = 0; i < vec_result.length; i++)
	{
		if (vec_result[i]!.length == 0)
		{
			//Значит комбинация Левой и Правой подстроки была Найдена, но между ними ничего не было.

			print('${vec_result[i]}');     //Выводим результат.  Значит комбинация Левой и Правой подстроки была Найдена, но между ними ничего не было.
		}
		else
		{
			print('${vec_result[i]}');                //Выводим результат.
			print(utf8.decode(vec_result[i]!));       //Просто для удобства наглядности сонвертируем его в String.[Если в vec_result[i] не валдиная UTF-8 кодировка, то рантайм выдаст ошибку.]
		}

	}
	//---------------------------------------------------------------------------------------------------
*/

  //----------------------------------------------------------------------------------------F-get_vector_string__with_pass:Начало---------------------------------------------------------------------------------------------







  //--------------------------------------------------------------------------------------1-Get_SubstrBetweenSubstr_PointerRanges__class::Конец---------------------------------------------------------------------------










  //--------------------------------------------------------------------------------------2-Get_SubstrBetweenSubstr_AllPointerRanges__class::Начало---------------------------------------------------------------------------


  //Доступные методы:
  //-get__EndPointer                           - делает Split с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки. Для этого внутри испотзуется "memcmp" для поиска подстроки.



  //-----------------------------------------------------------------------------------------------------get__EndPointer:Начало--------------------------------------------------------------------------------

  //Эта функия точно так же, как и "Get_SubstrBetweenSubstr_PointerRanges__class" возвращает указатели на подстроки между подстроками, НО ДОПОЛНИТЕЛЬНО возвращает еще указатели и их размеры на сами Ограничевающме подстроки, и то, что между ними. Это лучше всего смотреть на примере:
  //ЕДИНСВЕННОЕ ОТЛИЧИЕ ОТ ФУНКЦИИ "get" - СОСТОИТ В ТОМ, ЧТО ДАННАЯ ФУНКЦИЯ В КАЧЕСТВЕ КОНЦА ДИАПАЗОНА МОЖЕТ ПРИНИМАТЬ УКАЗАТЕЛЬ НА ПРОИЗВОЛЬНЫЙ БАЙТ СТРОКИ, А НЕ ТОЛЬКО НА КОНЕЦ СТРОКИ, КАК В  "get". ДЛЯ ЭТОГО В ДАННОЙ ФУНКЦИИ ИСПОЛЬЗУЕТСЯ "memcmp" ДЛЯ ПОИСКА ПОДСТРОКИ В СТРОКЕ.
  //ВНИМАНИЕ: ЕСЛИ между искомымы подстроками - будет точно такая же комбинации Левой и Правой подстроки, ТО: Для примера: 1[SMS[V]1][SMS2]{GEO/}[SMS34] - если мы ищем подстроку между "[" и "]" - и внутри этих есть такая же кобианция этих подстрок "[V]", то функция будет расматривать это как отдельные Комбинации, то есть как "[ SMS[V ]", а не как "[ SMS[V]1 ]".





  //Предположим у нас есть строка: 1S[SMS1][SMS2]{GEO/}[SMS34]5 -  и в ней мы хотим получить указатели на подстроки между подстроками "[" и "]" и на все остальные указатели, смотрим, функция выдаст следющий результат в виде вектора результата, который возвращает функция:
  /*
	1           -   vec_result_all_ranges[0].left_out_p         - указатель на начало того, что находится между Началом строки и Левой Огрничивающей подстроки "[" - АКУТАЛЕН ТОЛЬКО ПРИ vec_result_all_ranges[0].left_out_size > 0. vec_result_all_ranges[0].left_out_size = 2 - соответвенно размер байт от начала указателя ДО "[".
	S
	[           -   vec_result_all_ranges[0].left_external_p    - указатель на начало Левой Огрничивающей подстроки "[".  vec_result_all_ranges[0].left_external_size = 1                        - это соответвенно размер байт самой Левой Ограничевающей подстроки.
	S           -   vec_result_all_ranges[0].left_internal_p    - указатель на начало самой подстроки между "[" и "]" то есть на симивол "S",   vec_result_all_ranges[0].left_external_size = 4  - это соответвенно размер байт от начала указателя ДО начала Правой Ограничивающей подстроки, то есть до символа "]".
	M
	S
	1
	]           -   vec_result_all_ranges[0].right_external_p    - указатель на начало Правой Огрничивающей подстроки "]". vec_result_all_ranges[0].right_external_size = 1                      - это соответвенно размер байт самой Левой Ограничевающей подстроки.
	[           -   vec_result_all_ranges[1].left_external_p     - указатель на начало Левой Огрничивающей подстроки "[".  vec_result_all_ranges[0].left_external_size = 1                       - это соответвенно размер байт самой Левой Ограничевающей подстроки.;;; vec_result_all_ranges[1].left_out_p - в данном случае НЕ ВАЛИДНЫЙ, так как vec_result_all_ranges[1].left_out_size = 0, так как между Ограничивающими подстроками "]" и "[" - ничего нет.
	S           -   vec_result_all_ranges[1].left_internal_p     - указатель на начало самой подстроки между "[" и "]" то есть на симивол "S", vec_result_all_ranges[1].left_external_size = 4   - это соответвенно размер байт от начала указателя ДО начала Правой Ограничивающей подстроки, то есть до символа "]".
	M
	S
	2
	]           -   vec_result_all_ranges[1].right_external_p    - указатель на начало Правой Огрничивающей подстроки "]". vec_result_all_ranges[1].right_external_size = 1                      - это соответвенно размер байт самой Левой Ограничевающей подстроки.
	{           -   vec_result_all_ranges[2].left_out_p          - указатель на начало того, что находится между предыдущем Правой ограничивающей подстрокой в данном случае "]" строки и следующей найденной Огрничивающей подстроки "[" - АКУТАЛЕН ТОЛЬКО ПРИ vec_result_all_ranges[1].left_out_size > 0. vec_result_all_ranges[1].left_out_size = 6 - соответвенно размер байт от начала указателя ДО "[".
	H
	U
	Y
	/
	}
	[           -   vec_result_all_ranges[2].left_external_p     - указатель на начало Левой Огрничивающей подстроки "[".  vec_result_all_ranges[2].left_external_size = 1                       - это соответвенно размер байт самой Левой Ограничевающей подстроки.
	S           -   vec_result_all_ranges[2].left_internal_p     - указатель на начало самой подстроки между "[" и "]" то есть на симивол "S",   vec_result_all_ranges[2].left_external_size = 4 - это соответвенно размер байт от начала указателя ДО начала Правой Ограничивающей подстроки, то есть до символа "]".
	M
	S
	3
	4
	]           -   vec_result_all_ranges[2].right_external_p    - указатель на начало Правой Огрничивающей подстроки "]". vec_result_all_ranges[2].right_external_size = 1                      - это соответвенно размер байт самой Левой Ограничевающей подстроки.
	5           -   vec_result_all_ranges[2].right_out_p         - "заверщающий хвост" - если он есть, ТО ТОЛЬКО всегда у последнего найденого элемента. vec_result_all_ranges[2].right_out_size = 1  - это соответвенно размер байт самого "завершаюшего хвоста".
	*/

/*
  Get_SubstrBetweenSubstr_AllPointerRanges__class.Get_SubstrBetweenSubstr_AllPointerRanges__class My_GET_pointer_substring_AllRanges = new Get_SubstrBetweenSubstr_AllPointerRanges__class.Get_SubstrBetweenSubstr_AllPointerRanges__class();


	//-----------------------------------------------------------------------------------------------------
	Uint8List my_string = Uint8List.fromList(utf8.encode("1[SMS1][SMS2]{GEO/}[SMS34]5"));

	Get_SubstrBetweenSubstr_AllPointerRanges__class.request_struct req_all_ranges = new Get_SubstrBetweenSubstr_AllPointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("[")), "[".length, Uint8List.fromList(utf8.encode("]")), "]".length );       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
	//req_.left_p = Uint8List.fromList(utf8.encode("["));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.left_size = "[".length;                                      //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

	//req_.right_p = Uint8List.fromList(utf8.encode("]"));               //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
	//req_.right_size = "[".length;                                                          Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!



	List<Get_SubstrBetweenSubstr_AllPointerRanges__class.result_struct> vec_result_all_ranges = [];       //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.


	int beg = 0;                     //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
	int end = my_string.length-1;                 //Указатель на конец диапазона в строке, до котрого включительно необходимо искать подстроку.
	//-----------------------------------------------------------------------------------------------------



	final int result_split_B = My_GET_pointer_substring_AllRanges.get__EndPointer(my_string, beg, end, req_all_ranges, vec_result_all_ranges);      //Функция возвращает кол-во найденных последовталеьностей.  0 - если ничего не найдено.


	if (result_split_B == 0)
	{
		print("Substr not found");
		return;
	}

	print('result:${result_split_B}');


	for (int i = 0; i < vec_result_all_ranges.length; i++)
	{

		print("------------------------------------------");

		if (vec_result_all_ranges[i].left_out_size > 0)
		{
			print('left_out_p:${vec_result_all_ranges[i].left_out_p}');
			print('left_out_size:${vec_result_all_ranges[i].left_out_size}');
		}

		print('left_external_p:${vec_result_all_ranges[i].left_external_p}');
		print('left_external_size:${vec_result_all_ranges[i].left_external_size}');

		print('left_internal_p:${vec_result_all_ranges[i].left_internal_p}');
		print('internal_size:${vec_result_all_ranges[i].internal_size}');

		print('right_external_size:${vec_result_all_ranges[i].right_external_p}');
		print('right_external_size:${vec_result_all_ranges[i].right_external_size}');

    print("------------------------------------------");
	}



	if (vec_result_all_ranges.last.right_out_p != 0)
	{
		print("------------------tail:beg------------------------");

		print("right_out_p:${vec_result_all_ranges.last.right_out_p}");                    //Конец только на самом последнем элементе вектора "vec_result_all_ranges", если после Правой ограничевающей подстроки еще были символы до окнца строки
		print("right_out_size:${vec_result_all_ranges.last.right_out_size}");

		print("------------------tail:end------------------------");
	}

*/
  //-----------------------------------------------------------------------------------------------------get__EndPointer:Конец--------------------------------------------------------------------------------





  //--------------------------------------------------------------------------------------2-Get_SubstrBetweenSubstr_AllPointerRanges__class::Конец---------------------------------------------------------------------------












  //----------------------------------------------------------------------------------------------------3-Get_Split_AllPointerRanges__class::Начало---------------------------------------------------------------------------


  //Доступные методы:
  //-get__EndPointer                           - делает Split с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки.



  //-------------------------------------------------------------------------------------------get__EndPointer:Начало--------------------------------------------------------------------------------------------------------


  //Эта функция Split - разделения строки по заданной подстроке на ВСЕ диапазоны, вообщем функция возвращает указатели и размеры по ВСЕМ разделенным диапазонам. Лучше всего это смотреть на примере:

  //Предположим у нас есть строка: 1S[SMS1][SMS2]{GEO/}[SMS34]5 -  и в ней мы хотим сделать Split по подстроке "SMS" -  функция выдаст следющий результат в виде вектора резульата, который возвращает функция:
  /*
	1           -   vec_result_all_ranges[0].left_out_p          - указатель на начало того, что находится между Началом строки и найденой Подстрокой "SMS" - АКУТАЛЕН ТОЛЬКО ПРИ vec_result_all_ranges[0].left_out_size > 0. vec_result_all_ranges[0].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS".
	S
	[
	S           -   vec_result_all_ranges[0].substr_found_p      - указатель на начало самой найдено подстроки "SMS",   vec_result_all_ranges[0].substr_found_size = 3  - это соответвенно размер байт самой найденой подстроки.
	M
	S
	1           -   vec_result_all_ranges[1].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки - АКУТАЛЕН ТОЛЬКО ПРИ vec_result_all_ranges[1].left_out_size > 0. vec_result_all_ranges[2].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS".
	]
	[
	S           -   vec_result_all_ranges[1].substr_found_p      - указатель на начало самой найдено подстроки "SMS",   vec_result_all_ranges[1].substr_found_size = 3  - это соответвенно размер байт самой найденой подстроки.
	M
	S
	2           -   vec_result_all_ranges[2].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки - АКУТАЛЕН ТОЛЬКО ПРИ vec_result_all_ranges[1].left_out_size > 0. vec_result_all_ranges[2].left_out_size = 9 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS".
	]
	{
	H
	U
	Y
	/
	}
	[
	S           -   vec_result_all_ranges[2].substr_found_p      - указатель на начало самой найдено подстроки "SMS",   vec_result_all_ranges[1].substr_found_size = 3  - это соответвенно размер байт самой найденой подстроки.
	M
	S
	3           -   vec_result_all_ranges[2].right_out_p         - "заверщающий хвост" - если он есть, ТО ТОЛЬКО всегда у последнего найденого элемента. vec_result_all_ranges[2].right_out_size = 4  - это соответвенно размер байт самого "завершаюшего хвоста".
	4
	]
	5
	*/


/*
    //-----------------------------------------------------------------------------------------------
    Get_Split_AllPointerRanges__class.Get_Split_AllPointerRanges__class My_GET_pointer_substring_split_AllRanges = new Get_Split_AllPointerRanges__class.Get_Split_AllPointerRanges__class();


    Uint8List my_string_for_split = Uint8List.fromList(utf8.encode("5[SMS1][SMS2]{GEO/}[SMS34]"));    //"1[SMS1][SMS2]{GEO/}[SMS34]";

		Get_Split_AllPointerRanges__class.request_struct req_split = new Get_Split_AllPointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("SMS")), "SMS".length); ;       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
		//req_split.pointer_to_subsrt = Uint8List.fromList(utf8.encode("SMS"));      //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!                                                Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
		//req_split.subsrt_size = "SMS".length;   ;                                  // //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!


		List<Get_Split_AllPointerRanges__class.result_struct>vec_result_split = [];       //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.


		int beg_split = 0;                               //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
    int end_split = my_string_for_split.length-1;      //Указатель на конец диапазона до которого включительно нужно искать. Может быть любой элемент в буффере, НО должен быть есесвенно больше или равен, чем "beg_split_".
    //-----------------------------------------------------------------------------------------------



		final int result_split = My_GET_pointer_substring_split_AllRanges.get__EndPointer(my_string_for_split, beg_split, end_split, req_split, vec_result_split);      //Функция возвращает кол-во найденных последовталеьностей.  0 - если ничего не найдено/


	if (result_split == 0)
	{
    print("Substr not found");

		return;
	}

    print('result:${result_split}');


		for (int i = 0; i < vec_result_split.length; i++)
		{
      print("------------------------------------------");

			if (vec_result_split[i].left_out_size > -1)
			{
        print('left_out_p:${vec_result_split[i].left_out_p}');
        print('left_out_p:${vec_result_split[i].left_out_size}\n');
			}

      print('substr_found_p:${vec_result_split[i].substr_found_p}');
      print('substr_found_size:${vec_result_split[i].substr_found_size}');

      print("------------------------------------------");
		}


    print("------------------tail:beg------------------------");

		if (vec_result_split.last.right_out_p != -1)
		{
      print('right_out_p:${vec_result_split.last.right_out_p}');   //Конец только на самом последнем элементе вектора "vec_result_split", если после Послдений найденой подстроки еще были символы до конца строки.
      print('right_out_size:${vec_result_split.last.right_out_size}');
		}

    print("------------------tail:end------------------------");

*/
  //-------------------------------------------------------------------------------------------get__EndPointer:Конец--------------------------------------------------------------------------------------------------------




  //-----------------------------------------------------------------------------------------------------3-Get_Split_AllPointerRanges__class::Конец---------------------------------------------------------------------------










  //----------------------------------------------------------------------------------------------------4-Get_Split_PointerRanges__class::Начало---------------------------------------------------------------------------


  //Доступные методы:
  //-get_vector_pointer__Limit_Counter         - Делает все тоже самое, что и "get_vector_pointer__EndPointer", но имеет возможность указать, какое кол-во Сплит-элементов возвращать, как результат.
  //-get_vector_string__Limit_Counter          - Делает все тоже самое, что и "get_vector_string__EndPointer", но имеет возможность указать, какое кол-во Сплит-элементов возвращать, как результат.
  //-get_vector_pointer__EndPointer            - делает Split с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки.
  //-get_vector_string__EndPointer             - делает Split с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки.

  //--------------------------------------------------------------------------------------A-get_vector_pointer__EndPointer:Начало-----------------------------------------------------------------------------------------------


  //Эта функция Split - разделения строки по заданной подстроке на диапазоны, вообщем функция возвращает указатели и размеры на диапазоны разделения. Лучше всего это смотреть на примере:

  //Предположим у нас есть строка: 1S[SMS1][SMS2]{GEO/}[SMS34]5 -  и в ней мы хотим сделать Split по подстроке "SMS" -  функция выдаст следющий результат в виде вектора резульата, который возвращает функция:
  /*
		1           -   vec_result_all_ranges[0].left_out_p          - указатель на начало того, что находится между Началом строки и найденой Подстрокой "SMS". vec_result_all_ranges[0].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		S
		[
		S
		M
		S
		1           -   vec_result_all_ranges[1].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[1].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		]
		[
		S
		M
		S
		2           -   vec_result_all_ranges[2].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[2].left_out_size = 9 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		]
		{
		H
		U
		Y
		/
		}
		[
		S
		M
		S
		3           -   vec_result_all_ranges[3].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[3].left_out_size = 4 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		4
		]
		5
		*/



/*
	//--------------------------------------------------------------------------------
  Get_Split_PointerRanges__class.Get_Split_PointerRanges__class My_GET_pointer_substring_split = new Get_Split_PointerRanges__class.Get_Split_PointerRanges__class();


  Uint8List my_string_for_split_ = Uint8List.fromList(utf8.encode("1[SMS1][SMS2]{GEO/}[SMS34]"));    //"1[SMS1][SMS2]{GEO/}[SMS34]";

  Get_Split_PointerRanges__class.request_struct req_split_ = new Get_Split_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("SMS")), "SMS".length);       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
  req_split_.pointer_to_subsrt = Uint8List.fromList(utf8.encode("SMS1"));        //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!         Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
  req_split_.subsrt_size       = "SMS1".length;                                 //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

	List<Get_Split_PointerRanges__class.result_struct> vec_result_split_=[];         //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.


	int beg_split_ = 0;                                 //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
  int end_split_ = my_string_for_split_.length-1;     //Указатель на конец диапазона до которого включительно нужно искать. Может быть любой элемент в буффере, НО должен быть есесвенно больше или равен, чем "beg_split_".
    //--------------------------------------------------------------------------------


	//--------------------------------------------------------------------------------
	final int result_split_ = My_GET_pointer_substring_split.get_vector_pointer__EndPointer(my_string_for_split_, beg_split_, end_split_, req_split_, vec_result_split_);      //Функция возвращает кол-во найденных последовталеьностей.  0 - если ничего не найдено.

  print('result:${result_split_}');


	for (int i = 0; i < vec_result_split_.length; i++)
	{
    print("------------------------------------------");

    print('left_out_p:${vec_result_split_[i].split_range_p}');
    print('split_range_size:${vec_result_split_[i].split_range_size}');        //РАЗМЕР ВСЕГДА БУДЕТ БОЛЬШЕ НУЛЯ, ТО ЕСТЬ В ВЕКТОР РЕЗУЛЬТАТОВ НЕ ЗАНОСИТСЯ РАЗМЕР НУЛЕВОГО ДИАПАЗОНА, ТО ЕСТЬ КОГДА ИСКОМЫЕ ПОДСТРОКИ ИДУТ СРАЗУ ДРУГ ЗА ДРУГОМ.

     print("------------------------------------------");
	}
	//--------------------------------------------------------------------------------
*/
  //--------------------------------------------------------------------------------------A-get_vector_pointer__EndPointer:Конец-----------------------------------------------------------------------------------------------





  //--------------------------------------------------------------------------------------B-get_vector_string__EndPointer:Начало-----------------------------------------------------------------------------------------------


  //Эта функция Split - разделения строки по заданной подстроке на диапазоны, вообщем функция возвращает std::string на диапазоны разделения. Лучше всего это смотреть на примере:


  //Предположим у нас есть строка: 1S[SMS1][SMS2]{GEO/}[SMS34]5 -  и в ней мы хотим сделать Split по подстроке "SMS" -  функция выдаст следющий результат в виде вектора резульата, который возвращает функция:
  /*
		1           -   vec_result_all_ranges[0].left_out_p          - указатель на начало того, что находится между Началом строки и найденой Подстрокой "SMS". vec_result_all_ranges[0].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		S
		[
		S
		M
		S
		1           -   vec_result_all_ranges[1].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[1].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		]
		[
		S
		M
		S
		2           -   vec_result_all_ranges[2].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[2].left_out_size = 9 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		]
		{
		H
		U
		Y
		/
		}
		[
		S
		M
		S
		3           -   vec_result_all_ranges[3].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[3].left_out_size = 4 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		4
		]
		5
		*/



/*
      //--------------------------------------------------------------------------------
      Get_Split_PointerRanges__class.Get_Split_PointerRanges__class My_GET_pointer_substring_split = new Get_Split_PointerRanges__class.Get_Split_PointerRanges__class();


      Uint8List my_string_for_split_ = Uint8List.fromList(utf8.encode("7[SMS1][SMS2]{GEO/}[SMS34]"));    //"1[SMS1][SMS2]{GEO/}[SMS34]";

      Get_Split_PointerRanges__class.request_struct req_split_ = new Get_Split_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("SMS")), "SMS".length);       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
      req_split_.pointer_to_subsrt = Uint8List.fromList(utf8.encode("SMS"));        //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!         Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
      req_split_.subsrt_size       = "SMS".length;                                 //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!


      List<Uint8List?> vec_result_split_=[];                              //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.


			int beg_split_ = 0;                                   //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
			int end_split_ = my_string_for_split_.length-1;       //Указатель на конец диапазона до которого включительно нужно искать. Может быть любой элемент в буффере, НО должен быть есесвенно больше или равен, чем "beg_split_".
			//--------------------------------------------------------------------------------



			//--------------------------------------------------------------------------------
			final int result_split_ = My_GET_pointer_substring_split.get_vector_string__EndPointer(my_string_for_split_, beg_split_, end_split_, req_split_, vec_result_split_);      //Функция возвращает кол-во найденных последовталеьностей.  0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.

      print('result:${result_split_}');

			for (int i = 0; i < vec_result_split_.length; i++)
			{
        print("------------------------------------------");

        print(vec_result_split_[i]);
        print(utf8.decode(vec_result_split_[i]!));         //Просто для удобства наглядности сонвертируем его в String.[Если в vec_result[i] не валдиная UTF-8 кодировка, то рантайм выдаст ошибку.]

        print("------------------------------------------");
			}
			//--------------------------------------------------------------------------------
*/

  //--------------------------------------------------------------------------------------B-get_vector_string__EndPointer:Конец-----------------------------------------------------------------------------------------------



  //--------------------------------------------------------------------------------------C-get_vector_pointer__Limit_Counter:Начало-----------------------------------------------------------------------------------------------


  //Эта функция Split - разделения строки по заданной подстроке на диапазоны, вообщем функция возвращает указатели и размеры на диапазоны разделения. Лучше всего это смотреть на примере:

  //Предположим у нас есть строка: 1S[SMS1][SMS2]{GEO/}[SMS34]5 -  и в ней мы хотим сделать Split по подстроке "SMS" -  функция выдаст следющий результат в виде вектора резульата, который возвращает функция:
  /*
				 1           -   vec_result_all_ranges[0].left_out_p          - указатель на начало того, что находится между Началом строки и найденой Подстрокой "SMS". vec_result_all_ranges[0].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
				 S
				 [
				 S
				 M
				 S
				 1           -   vec_result_all_ranges[1].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[1].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
				 ]
				 [
				 S
				 M
				 S
				 2           -   vec_result_all_ranges[2].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[2].left_out_size = 9 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
				 ]
				 {
				 H
				 U
				 Y
				 /
				 }
				 [
				 S
				 M
				 S
				 3           -   vec_result_all_ranges[3].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[3].left_out_size = 4 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
				 4
				 ]
				 5
				 */


/*
  //--------------------------------------------------------------------------------
  Get_Split_PointerRanges__class.Get_Split_PointerRanges__class My_GET_pointer_substring_split = new Get_Split_PointerRanges__class.Get_Split_PointerRanges__class();


  Uint8List my_string_for_split_ = Uint8List.fromList(utf8.encode("7[SMS1][SMS2]{GEO/}[SMS34]")); //"1[SMS1][SMS2]{GEO/}[SMS34]";

  Get_Split_PointerRanges__class.request_struct req_split_ = new Get_Split_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("SMS")), "SMS".length); //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
  req_split_.pointer_to_subsrt = Uint8List.fromList(utf8.encode("SMS")); //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!         Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
  req_split_.subsrt_size = "SMS".length; //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!

  List<Get_Split_PointerRanges__class.result_struct> vec_result_split_=[]; //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.

  int Limit_Counter = 1;                                                          //Кол-во элементов, которые разделит функция. ПРИМЕР: есть строка "1,2,3,4,5,6" - нужно разделить по ",". Если указать Limit_Counter=1, то возвратятся данные только для первого разделенного элемента, то есть для "1", если указать Limit_Counter=2, то сооветтвенно для двух, для "1" и "2".

  int beg_split_ = 0;                                 //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
  int end_split_ = my_string_for_split_.length - 1;  //Указатель на конец диапазона до которого включительно нужно искать. Может быть любой элемент в буффере, НО должен быть есесвенно больше или равен, чем "beg_split_".
   //--------------------------------------------------------------------------------


   //--------------------------------------------------------------------------------
  final int result_split_ = My_GET_pointer_substring_split.get_vector_pointer__Limit_Counter(my_string_for_split_, beg_split_, end_split_, req_split_, vec_result_split_, Limit_Counter); //Функция возвращает кол-во найденных последовталеьностей.  0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.

  print('result:${result_split_}');


  for (int i = 0; i < vec_result_split_.length; i++)
  {
  print("------------------------------------------");

  print('left_out_p:${vec_result_split_[i].split_range_p}');
  print('split_range_size:${vec_result_split_[i].split_range_size}');//РАЗМЕР ВСЕГДА БУДЕТ БОЛЬШЕ НУЛЯ, ТО ЕСТЬ В ВЕКТОР РЕЗУЛЬТАТОВ НЕ ЗАНОСИТСЯ РАЗМЕР НУЛЕВОГО ДИАПАЗОНА, ТО ЕСТЬ КОГДА ИСКОМЫЕ ПОДСТРОКИ ИДУТ СРАЗУ ДРУГ ЗА ДРУГОМ.

  print("------------------------------------------");
  }
  //--------------------------------------------------------------------------------

*/
  //--------------------------------------------------------------------------------------C-get_vector_pointer__Limit_Counter:Конец-----------------------------------------------------------------------------------------------








  //--------------------------------------------------------------------------------------D-get_vector_string__Limit_Counter:Начало-----------------------------------------------------------------------------------------------


  //Эта функция Split - разделения строки по заданной подстроке на диапазоны, вообщем функция возвращает std::string на диапазоны разделения. Лучше всего это смотреть на примере:


  //Предположим у нас есть строка: 1S[SMS1][SMS2]{GEO/}[SMS34]5 -  и в ней мы хотим сделать Split по подстроке "SMS" -  функция выдаст следющий результат в виде вектора резульата, который возвращает функция:
  /*
		1           -   vec_result_all_ranges[0].left_out_p          - указатель на начало того, что находится между Началом строки и найденой Подстрокой "SMS". vec_result_all_ranges[0].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		S
		[
		S
		M
		S
		1           -   vec_result_all_ranges[1].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[1].left_out_size = 3 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		]
		[
		S
		M
		S
		2           -   vec_result_all_ranges[2].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[2].left_out_size = 9 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		]
		{
		H
		U
		Y
		/
		}
		[
		S
		M
		S
		3           -   vec_result_all_ranges[3].left_out_p          - указатель на начало того, что находится между Началом найденной новой подстроки и символов, который следует сразу за окончанием предыдушей найденой подстроки. vec_result_all_ranges[3].left_out_size = 4 - соответвенно размер байт от начала указателя ДО начала искомой подстроки "SMS". Размер ВСЕГДА будет больше 0, то есть в вектор результатов не заносится нулевой диапазон.
		4
		]
		5
		*/



/*
      //--------------------------------------------------------------------------------
      Get_Split_PointerRanges__class.Get_Split_PointerRanges__class My_GET_pointer_substring_split = new Get_Split_PointerRanges__class.Get_Split_PointerRanges__class();


      Uint8List my_string_for_split_ = Uint8List.fromList(utf8.encode("7[SMS1][SMS2]{GEO/}[SMS34]"));    //"1[SMS1][SMS2]{GEO/}[SMS34]";

      Get_Split_PointerRanges__class.request_struct req_split_ = new Get_Split_PointerRanges__class.request_struct(Uint8List.fromList(utf8.encode("SMS")), "SMS".length);       //Структура запроса, где нужно указать указатели на Левую и Правую часть подстроки и их размеры - между которым необзодимо искать подстроку. Указываемоые Левые и Правые Подстроки могут быть любого размера.
      req_split_.pointer_to_subsrt = Uint8List.fromList(utf8.encode("SMS"));        //Указатель на подстроку НЕ ДОЛЖЕН БЫТЬ НУЛЕВЫМ!         Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!
      req_split_.subsrt_size       = "SMS".length;                                 //Подстрока НЕ ДОЛЖНА БЫТЬ НУЛЕВОГО РАЗМЕРА! Проверка внутри фуннкции не ведется, так что НЕОБХОДИМО СЛЕДИТЬ ЗА ЭТИМ!


      List<Uint8List?> vec_result_split_=[];                              //Вектор Результатов: Функция внутри не обнуляет вектор, а добавялет результат в конец переданного вектора, это удобно если нужно аккумулировать результаты. Если нужно чтобы вектор заполнялся с нуля, то предварительно нужно его занулить и все.

      int Limit_Counter = 1;                                                          //Кол-во элементов, которые разделит функция. ПРИМЕР: есть строка "1,2,3,4,5,6" - нужно разделить по ",". Если указать Limit_Counter=1, то возвратятся данные только для первого разделенного элемента, то есть для "1", если указать Limit_Counter=2, то сооветтвенно для двух, для "1" и "2".

			int beg_split_ = 0;                                //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
			int end_split_ = my_string_for_split_.length-1;    //Указатель на конец диапазона до которого включительно нужно искать. Может быть любой элемент в буффере, НО должен быть есесвенно больше или равен, чем "beg_split_".
			//--------------------------------------------------------------------------------



			//--------------------------------------------------------------------------------
			final int result_split_ = My_GET_pointer_substring_split.get_vector_string__Limit_Counter(my_string_for_split_, beg_split_, end_split_, req_split_, vec_result_split_, Limit_Counter);      //Функция возвращает кол-во найденных последовталеьностей.  0 - если ничего не найдено, и -1 - если вызвалось исключение bad_alloc.

      print('result:${result_split_}');

			for (int i = 0; i < vec_result_split_.length; i++)
			{
        print("------------------------------------------");

        print(vec_result_split_[i]);
        print(utf8.decode(vec_result_split_[i]!));            //Просто для удобства наглядности сонвертируем его в String.[Если в vec_result[i] не валдиная UTF-8 кодировка, то рантайм выдаст ошибку.]

        print("------------------------------------------");
			}
			//--------------------------------------------------------------------------------

*/
  //--------------------------------------------------------------------------------------D-get_vector_string__Limit_Counter:Конец-----------------------------------------------------------------------------------------------





  //-----------------------------------------------------------------------------------------------------4-Get_Split_PointerRanges__class::Конец---------------------------------------------------------------------------







	//--------------------------------------------------------------------------------------------------5-Get__Replace__class:Начало---------------------------------------------------------------------


	//Доступные методы:
	//-replace_to_NewString__EndPointer            - делает Replace с возможностью указывать конечный диапазон поиска в строке - отличного от конца этой строки. Для этого внутри испотзуется "memcmp" для поиска подстроки.

/*
	Get__Replace__class.Get__Replace__class Get__Replace__class_ = new Get__Replace__class.Get__Replace__class();



	//---------------------------------------------------------------------------------A-replace_to_NewString:Начало--------------------------------------------------------------------

		//Данная функция заменяет подстроку в строке на указанную подстроку и помещает результат в новый std::string.

		Uint8List my_string_for_replace_1 = Uint8List.fromList(utf8.encode("1[SMS1][SMS2]{GEO/}[SMS34]"));

	  Uint8List to_be_replace_1 = Uint8List.fromList(utf8.encode("SMS"));
	  Uint8List for_replace_1   = Uint8List.fromList(utf8.encode("GPRS"));

		//`````````````````````````````````````````````````````
		int pointer_to_BegString_1                = 0;                                         //Указатель на начало диапазона с которого нужно начать. Может быть любым указателем в строке, хоть с самого начала строки, хоть с середины, самое галвное меньше конечного указателя "end".
	  int pointer_to_EndString_1                = my_string_for_replace_1.length-1;          //Указатель на конец диапазона - может быть ТОЛЬКО последним элементом строки, то есть самым последним перед завержающим нулем.

	  Uint8List pointer_to_Substr_ToBeReplace_1 = to_be_replace_1;                           //Указатель на строку с текстом, который нужно заменить в строке по указателю "pointer_to_BegString"
	  int size_Substr_ToBeReplace_1             = to_be_replace_1.length;                    //Размер строки с текстом, который нужно заменить в строке по указателю "pointer_to_BegString"

	  Uint8List pointer_to_Substr_ForReplace_1  = for_replace_1;                             //[ЕСЛИ НУЖНО УДАЛИТЬ заменяемую посдтроку, то просто проинициализировать пустым буффером Uint8List(0)] Указатель на строку с текстом, на который нужно строку на которую указывает "pointer_to_Substr_ToBeReplace" в строке по указателю "pointer_to_BegString"
	  int size_Substr_ForReplace_1              = for_replace_1.length;                      //[ЕСЛИ НУЖНО УДАЛИТЬ заменяемую посдтроку, то указать 0 данным параметром] Размер строки с текстом, на который нужно строку на которую указывает "pointer_to_Substr_ToBeReplace" в строке по указателю "pointer_to_BegString"
		//`````````````````````````````````````````````````````



	//---------------------------------------------------------------------------
	(int, Uint8List?) result_replace_1 = Get__Replace__class_.replace_to_NewString__EndPointer(my_string_for_replace_1, pointer_to_BegString_1, pointer_to_EndString_1, pointer_to_Substr_ToBeReplace_1, size_Substr_ToBeReplace_1, pointer_to_Substr_ForReplace_1, size_Substr_ForReplace_1);
	//Функция возвращает "record":
	//-первый элемент int: 0 - значит не она подстроак не была найдена и заменена, любое значение большу нуля, говорит о кол-в замененных подстрок.
	//-второй элемент новый буффер за мененными подстроками, актуален только при int > 0.


		if (result_replace_1.$1 == 0)
		{
			print("Replace substring not found");

			return;
		}

		if (result_replace_1.$1 > 0)
		{
			print("Num Replace substring:${result_replace_1.$1}");
			
			print("result_replace_string:${result_replace_1.$2}");
			print("result_replace_string_to_String:${utf8.decode(result_replace_1.$2!)}");      //Просто для удобства наглядности сонвертируем его в String.[Если в vec_result[i] не валдиная UTF-8 кодировка, то рантайм выдаст ошибку.]
		}
		//---------------------------------------------------------------------------


	//---------------------------------------------------------------------------------A-replace_to_NewString:Конец--------------------------------------------------------------------
*/



	//--------------------------------------------------------------------------------------------------5-Get__Replace__class:Конец---------------------------------------------------------------------


}
